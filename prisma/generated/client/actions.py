# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'password': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'cadfabfehe',
                    'password': 'dgiiaaijj',
                },
                {
                    # data to create a User record
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 1062517886,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 267834847,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 180171308,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the password field
        users = await User.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the createdAt field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 836760821,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 595337866,
            },
            data={
                'create': {
                    'id': 595337866,
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
                'update': {
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'id': 790425851
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by name values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProblemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Problem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Problem.prisma().query_raw(
            'SELECT * FROM Problem WHERE id = $1',
            2111915288,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Problem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Problem.prisma().query_first(
            'SELECT * FROM Problem WHERE title = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProblemCreateInput,
        include: Optional[types.ProblemInclude] = None
    ) -> _PrismaModelT:
        """Create a new Problem record.

        Parameters
        ----------
        data
            Problem record data
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The created Problem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Problem record from just the required fields
        problem = await Problem.prisma().create(
            data={
                # data to create a Problem record
                'title': 'bgeecijdgg',
                'description': 'bdiicjafbj',
                'difficulty': enums.Difficulty.EASY,
                'creatorId': 1647418052,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProblemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Problem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Problem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Problem.prisma().create_many(
            data=[
                {
                    # data to create a Problem record
                    'title': 'bghffegacj',
                    'description': 'bhghchehcc',
                    'difficulty': enums.Difficulty.EASY,
                    'creatorId': 326272115,
                },
                {
                    # data to create a Problem record
                    'title': 'bdedcabahc',
                    'description': 'ghfhiafcb',
                    'difficulty': enums.Difficulty.EASY,
                    'creatorId': 744964398,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProblemWhereUniqueInput,
        include: Optional[types.ProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Problem record.

        Parameters
        ----------
        where
            Problem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The deleted Problem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem = await Problem.prisma().delete(
            where={
                'id': 1969681615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProblemWhereUniqueInput,
        include: Optional[types.ProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Problem record.

        Parameters
        ----------
        where
            Problem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The found Problem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem = await Problem.prisma().find_unique(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProblemWhereUniqueInput,
        include: Optional[types.ProblemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Problem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Problem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The found Problem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem = await Problem.prisma().find_unique_or_raise(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
        include: Optional[types.ProblemInclude] = None,
        order: Optional[Union[types.ProblemOrderByInput, List[types.ProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ProblemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Problem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Problem records returned
        skip
            Ignore the first N results
        where
            Problem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem model
        order
            Order the returned Problem records by any field
        distinct
            Filter Problem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Problem]
            The list of all Problem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Problem records
        problems = await Problem.prisma().find_many(take=10)

        # find the first 5 Problem records ordered by the description field
        problems = await Problem.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
        include: Optional[types.ProblemInclude] = None,
        order: Optional[Union[types.ProblemOrderByInput, List[types.ProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ProblemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Problem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Problem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem model
        order
            Order the returned Problem records by any field
        distinct
            Filter Problem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Problem
            The first Problem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Problem record ordered by the difficulty field
        problem = await Problem.prisma().find_first(
            skip=1,
            order={
                'difficulty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
        include: Optional[types.ProblemInclude] = None,
        order: Optional[Union[types.ProblemOrderByInput, List[types.ProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ProblemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Problem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Problem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem model
        order
            Order the returned Problem records by any field
        distinct
            Filter Problem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Problem
            The first Problem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Problem record ordered by the creatorId field
        problem = await Problem.prisma().find_first_or_raise(
            skip=1,
            order={
                'creatorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProblemUpdateInput,
        where: types.ProblemWhereUniqueInput,
        include: Optional[types.ProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Problem record.

        Parameters
        ----------
        data
            Problem record data specifying what to update
        where
            Problem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The updated Problem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        problem = await Problem.prisma().update(
            where={
                'id': 1303003706,
            },
            data={
                # data to update the Problem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProblemWhereUniqueInput,
        data: types.ProblemUpsertInput,
        include: Optional[types.ProblemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Problem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Problem model

        Returns
        -------
        prisma.models.Problem
            The created or updated Problem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem = await Problem.prisma().upsert(
            where={
                'id': 1686638315,
            },
            data={
                'create': {
                    'id': 1686638315,
                    'title': 'bdedcabahc',
                    'description': 'ghfhiafcb',
                    'difficulty': enums.Difficulty.EASY,
                    'creatorId': 744964398,
                },
                'update': {
                    'title': 'bdedcabahc',
                    'description': 'ghfhiafcb',
                    'difficulty': enums.Difficulty.EASY,
                    'creatorId': 744964398,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProblemUpdateManyMutationInput,
        where: types.ProblemWhereInput,
    ) -> int:
        """Update multiple Problem records

        Parameters
        ----------
        data
            Problem data to update the selected Problem records to
        where
            Filter to select the Problem records to update

        Returns
        -------
        int
            The total number of Problem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Problem records
        total = await Problem.prisma().update_many(
            data={
                'tags': ['caaaedabfc']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Problem records present in the database

        Parameters
        ----------
        select
            Select the Problem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Problem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProblemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Problem.prisma().count()

        # results: prisma.types.ProblemCountAggregateOutput
        results = await Problem.prisma().count(
            select={
                '_all': True,
                'edgedata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProblemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
    ) -> types.ProblemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProblemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProblemWhereInput] = None,
        cursor: Optional[types.ProblemWhereUniqueInput] = None,
    ) -> Union[int, types.ProblemCountAggregateOutput]:
        """Count the number of Problem records present in the database

        Parameters
        ----------
        select
            Select the Problem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Problem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProblemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Problem.prisma().count()

        # results: prisma.types.ProblemCountAggregateOutput
        results = await Problem.prisma().count(
            select={
                '_all': True,
                'nodedata': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProblemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProblemWhereInput] = None
    ) -> int:
        """Delete multiple Problem records.

        Parameters
        ----------
        where
            Optional Problem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Problem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Problem records
        total = await Problem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProblemScalarFieldKeys'],
        *,
        where: Optional['types.ProblemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProblemAvgAggregateInput'] = None,
        sum: Optional['types.ProblemSumAggregateInput'] = None,
        min: Optional['types.ProblemMinAggregateInput'] = None,
        max: Optional['types.ProblemMaxAggregateInput'] = None,
        having: Optional['types.ProblemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProblemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProblemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProblemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProblemGroupByOutput']:
        """Group Problem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Problem fields to group records by
        where
            Problem filter to select records
        take
            Limit the maximum number of Problem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProblemGroupByOutput]
            A list of dictionaries representing the Problem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Problem records by id values
        # and count how many records are in each group
        results = await Problem.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class Problem_codeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Problem_code]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Problem_code.prisma().query_raw(
            'SELECT * FROM Problem_code WHERE id = $1',
            1868141281,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Problem_code
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Problem_code.prisma().query_first(
            'SELECT * FROM Problem_code WHERE function = $1',
            'bigaiehgcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.Problem_codeCreateInput,
        include: Optional[types.Problem_codeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Problem_code record.

        Parameters
        ----------
        data
            Problem_code record data
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The created Problem_code record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Problem_code record from just the required fields
        problem_code = await Problem_code.prisma().create(
            data={
                # data to create a Problem_code record
                'function': 'beeifcbebf',
                'language': enums.Language.PYTHON,
                'testcases': 'bgcigfahea',
                'checker': 'bcejgaggif',
                'problemId': 835903122,
                'userId': 763719779,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.Problem_codeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Problem_code records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Problem_code record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Problem_code.prisma().create_many(
            data=[
                {
                    # data to create a Problem_code record
                    'function': 'ecjjjfbae',
                    'language': enums.Language.PYTHON,
                    'testcases': 'bhhfibbigf',
                    'checker': 'ijdbeffgg',
                    'problemId': 995405759,
                    'userId': 2102736524,
                },
                {
                    # data to create a Problem_code record
                    'function': 'chbfcacbd',
                    'language': enums.Language.PYTHON,
                    'testcases': 'efggddide',
                    'checker': 'caficfigfb',
                    'problemId': 1583689592,
                    'userId': 878442065,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.Problem_codeWhereUniqueInput,
        include: Optional[types.Problem_codeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Problem_code record.

        Parameters
        ----------
        where
            Problem_code filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The deleted Problem_code record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem_code = await Problem_code.prisma().delete(
            where={
                'id': 1675280054,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.Problem_codeWhereUniqueInput,
        include: Optional[types.Problem_codeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Problem_code record.

        Parameters
        ----------
        where
            Problem_code filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The found Problem_code record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem_code = await Problem_code.prisma().find_unique(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.Problem_codeWhereUniqueInput,
        include: Optional[types.Problem_codeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Problem_code record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Problem_code filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The found Problem_code record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem_code = await Problem_code.prisma().find_unique_or_raise(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
        include: Optional[types.Problem_codeInclude] = None,
        order: Optional[Union[types.Problem_codeOrderByInput, List[types.Problem_codeOrderByInput]]] = None,
        distinct: Optional[List[types.Problem_codeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Problem_code records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Problem_code records returned
        skip
            Ignore the first N results
        where
            Problem_code filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem_code model
        order
            Order the returned Problem_code records by any field
        distinct
            Filter Problem_code records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Problem_code]
            The list of all Problem_code records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Problem_code records
        problem_codes = await Problem_code.prisma().find_many(take=10)

        # find the first 5 Problem_code records ordered by the language field
        problem_codes = await Problem_code.prisma().find_many(
            take=5,
            order={
                'language': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
        include: Optional[types.Problem_codeInclude] = None,
        order: Optional[Union[types.Problem_codeOrderByInput, List[types.Problem_codeOrderByInput]]] = None,
        distinct: Optional[List[types.Problem_codeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Problem_code record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Problem_code filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem_code model
        order
            Order the returned Problem_code records by any field
        distinct
            Filter Problem_code records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Problem_code
            The first Problem_code record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Problem_code record ordered by the testcases field
        problem_code = await Problem_code.prisma().find_first(
            skip=1,
            order={
                'testcases': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
        include: Optional[types.Problem_codeInclude] = None,
        order: Optional[Union[types.Problem_codeOrderByInput, List[types.Problem_codeOrderByInput]]] = None,
        distinct: Optional[List[types.Problem_codeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Problem_code record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Problem_code filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Problem_code model
        order
            Order the returned Problem_code records by any field
        distinct
            Filter Problem_code records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Problem_code
            The first Problem_code record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Problem_code record ordered by the checker field
        problem_code = await Problem_code.prisma().find_first_or_raise(
            skip=1,
            order={
                'checker': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.Problem_codeUpdateInput,
        where: types.Problem_codeWhereUniqueInput,
        include: Optional[types.Problem_codeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Problem_code record.

        Parameters
        ----------
        data
            Problem_code record data specifying what to update
        where
            Problem_code filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The updated Problem_code record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        problem_code = await Problem_code.prisma().update(
            where={
                'id': 60335757,
            },
            data={
                # data to update the Problem_code record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.Problem_codeWhereUniqueInput,
        data: types.Problem_codeUpsertInput,
        include: Optional[types.Problem_codeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Problem_code filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Problem_code model

        Returns
        -------
        prisma.models.Problem_code
            The created or updated Problem_code record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        problem_code = await Problem_code.prisma().upsert(
            where={
                'id': 684462146,
            },
            data={
                'create': {
                    'id': 684462146,
                    'function': 'chbfcacbd',
                    'language': enums.Language.PYTHON,
                    'testcases': 'efggddide',
                    'checker': 'caficfigfb',
                    'problemId': 1583689592,
                    'userId': 878442065,
                },
                'update': {
                    'function': 'chbfcacbd',
                    'language': enums.Language.PYTHON,
                    'testcases': 'efggddide',
                    'checker': 'caficfigfb',
                    'problemId': 1583689592,
                    'userId': 878442065,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.Problem_codeUpdateManyMutationInput,
        where: types.Problem_codeWhereInput,
    ) -> int:
        """Update multiple Problem_code records

        Parameters
        ----------
        data
            Problem_code data to update the selected Problem_code records to
        where
            Filter to select the Problem_code records to update

        Returns
        -------
        int
            The total number of Problem_code records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Problem_code records
        total = await Problem_code.prisma().update_many(
            data={
                'problemId': 1625503827
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Problem_code records present in the database

        Parameters
        ----------
        select
            Select the Problem_code fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Problem_code filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Problem_codeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Problem_code.prisma().count()

        # results: prisma.types.Problem_codeCountAggregateOutput
        results = await Problem_code.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.Problem_codeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
    ) -> types.Problem_codeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.Problem_codeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.Problem_codeWhereInput] = None,
        cursor: Optional[types.Problem_codeWhereUniqueInput] = None,
    ) -> Union[int, types.Problem_codeCountAggregateOutput]:
        """Count the number of Problem_code records present in the database

        Parameters
        ----------
        select
            Select the Problem_code fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Problem_code filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.Problem_codeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Problem_code.prisma().count()

        # results: prisma.types.Problem_codeCountAggregateOutput
        results = await Problem_code.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.Problem_codeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.Problem_codeWhereInput] = None
    ) -> int:
        """Delete multiple Problem_code records.

        Parameters
        ----------
        where
            Optional Problem_code filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Problem_code records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Problem_code records
        total = await Problem_code.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.Problem_codeScalarFieldKeys'],
        *,
        where: Optional['types.Problem_codeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.Problem_codeAvgAggregateInput'] = None,
        sum: Optional['types.Problem_codeSumAggregateInput'] = None,
        min: Optional['types.Problem_codeMinAggregateInput'] = None,
        max: Optional['types.Problem_codeMaxAggregateInput'] = None,
        having: Optional['types.Problem_codeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.Problem_codeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.Problem_codeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.Problem_codeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.Problem_codeGroupByOutput']:
        """Group Problem_code records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Problem_code fields to group records by
        where
            Problem_code filter to select records
        take
            Limit the maximum number of Problem_code records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.Problem_codeGroupByOutput]
            A list of dictionaries representing the Problem_code record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Problem_code records by id values
        # and count how many records are in each group
        results = await Problem_code.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SubmissionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Submission]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Submission.prisma().query_raw(
            'SELECT * FROM Submission WHERE id = $1',
            521827728,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Submission
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Submission.prisma().query_first(
            'SELECT * FROM Submission WHERE code = $1',
            'bcggadccgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SubmissionCreateInput,
        include: Optional[types.SubmissionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Submission record.

        Parameters
        ----------
        data
            Submission record data
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The created Submission record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Submission record from just the required fields
        submission = await Submission.prisma().create(
            data={
                # data to create a Submission record
                'code': 'jdcfdcgc',
                'language': enums.Language.PYTHON,
                'status': 'cafdaehjid',
                'userId': 685333180,
                'problemId': 127474245,
                'score': 948921754,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SubmissionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Submission records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Submission record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Submission.prisma().create_many(
            data=[
                {
                    # data to create a Submission record
                    'code': 'bjgejjabff',
                    'language': enums.Language.PYTHON,
                    'status': 'bcciijbibg',
                    'userId': 255202753,
                    'problemId': 1223573862,
                    'score': 541269159,
                },
                {
                    # data to create a Submission record
                    'code': 'bageiegghg',
                    'language': enums.Language.PYTHON,
                    'status': 'faidicegb',
                    'userId': 1024265714,
                    'problemId': 872078403,
                    'score': 1874748096,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SubmissionWhereUniqueInput,
        include: Optional[types.SubmissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Submission record.

        Parameters
        ----------
        where
            Submission filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The deleted Submission record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        submission = await Submission.prisma().delete(
            where={
                'id': 916896761,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SubmissionWhereUniqueInput,
        include: Optional[types.SubmissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Submission record.

        Parameters
        ----------
        where
            Submission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The found Submission record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        submission = await Submission.prisma().find_unique(
            where={
                'id': 769267518,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SubmissionWhereUniqueInput,
        include: Optional[types.SubmissionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Submission record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Submission filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The found Submission record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        submission = await Submission.prisma().find_unique_or_raise(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
        include: Optional[types.SubmissionInclude] = None,
        order: Optional[Union[types.SubmissionOrderByInput, List[types.SubmissionOrderByInput]]] = None,
        distinct: Optional[List[types.SubmissionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Submission records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Submission records returned
        skip
            Ignore the first N results
        where
            Submission filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Submission model
        order
            Order the returned Submission records by any field
        distinct
            Filter Submission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Submission]
            The list of all Submission records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Submission records
        submissions = await Submission.prisma().find_many(take=10)

        # find the first 5 Submission records ordered by the language field
        submissions = await Submission.prisma().find_many(
            take=5,
            order={
                'language': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
        include: Optional[types.SubmissionInclude] = None,
        order: Optional[Union[types.SubmissionOrderByInput, List[types.SubmissionOrderByInput]]] = None,
        distinct: Optional[List[types.SubmissionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Submission record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Submission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Submission model
        order
            Order the returned Submission records by any field
        distinct
            Filter Submission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Submission
            The first Submission record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Submission record ordered by the status field
        submission = await Submission.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
        include: Optional[types.SubmissionInclude] = None,
        order: Optional[Union[types.SubmissionOrderByInput, List[types.SubmissionOrderByInput]]] = None,
        distinct: Optional[List[types.SubmissionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Submission record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Submission filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Submission model
        order
            Order the returned Submission records by any field
        distinct
            Filter Submission records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Submission
            The first Submission record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Submission record ordered by the userId field
        submission = await Submission.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SubmissionUpdateInput,
        where: types.SubmissionWhereUniqueInput,
        include: Optional[types.SubmissionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Submission record.

        Parameters
        ----------
        data
            Submission record data specifying what to update
        where
            Submission filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The updated Submission record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        submission = await Submission.prisma().update(
            where={
                'id': 92728044,
            },
            data={
                # data to update the Submission record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SubmissionWhereUniqueInput,
        data: types.SubmissionUpsertInput,
        include: Optional[types.SubmissionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Submission filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Submission model

        Returns
        -------
        prisma.models.Submission
            The created or updated Submission record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        submission = await Submission.prisma().upsert(
            where={
                'id': 344858293,
            },
            data={
                'create': {
                    'id': 344858293,
                    'code': 'bageiegghg',
                    'language': enums.Language.PYTHON,
                    'status': 'faidicegb',
                    'userId': 1024265714,
                    'problemId': 872078403,
                    'score': 1874748096,
                },
                'update': {
                    'code': 'bageiegghg',
                    'language': enums.Language.PYTHON,
                    'status': 'faidicegb',
                    'userId': 1024265714,
                    'problemId': 872078403,
                    'score': 1874748096,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SubmissionUpdateManyMutationInput,
        where: types.SubmissionWhereInput,
    ) -> int:
        """Update multiple Submission records

        Parameters
        ----------
        data
            Submission data to update the selected Submission records to
        where
            Filter to select the Submission records to update

        Returns
        -------
        int
            The total number of Submission records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Submission records
        total = await Submission.prisma().update_many(
            data={
                'problemId': 1121741130
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Submission records present in the database

        Parameters
        ----------
        select
            Select the Submission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Submission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubmissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Submission.prisma().count()

        # results: prisma.types.SubmissionCountAggregateOutput
        results = await Submission.prisma().count(
            select={
                '_all': True,
                'score': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SubmissionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
    ) -> types.SubmissionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SubmissionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SubmissionWhereInput] = None,
        cursor: Optional[types.SubmissionWhereUniqueInput] = None,
    ) -> Union[int, types.SubmissionCountAggregateOutput]:
        """Count the number of Submission records present in the database

        Parameters
        ----------
        select
            Select the Submission fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Submission filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SubmissionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Submission.prisma().count()

        # results: prisma.types.SubmissionCountAggregateOutput
        results = await Submission.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SubmissionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SubmissionWhereInput] = None
    ) -> int:
        """Delete multiple Submission records.

        Parameters
        ----------
        where
            Optional Submission filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Submission records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Submission records
        total = await Submission.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SubmissionScalarFieldKeys'],
        *,
        where: Optional['types.SubmissionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SubmissionAvgAggregateInput'] = None,
        sum: Optional['types.SubmissionSumAggregateInput'] = None,
        min: Optional['types.SubmissionMinAggregateInput'] = None,
        max: Optional['types.SubmissionMaxAggregateInput'] = None,
        having: Optional['types.SubmissionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SubmissionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SubmissionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SubmissionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SubmissionGroupByOutput']:
        """Group Submission records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Submission fields to group records by
        where
            Submission filter to select records
        take
            Limit the maximum number of Submission records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SubmissionGroupByOutput]
            A list of dictionaries representing the Submission record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Submission records by id values
        # and count how many records are in each group
        results = await Submission.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContestActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contest]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Contest.prisma().query_raw(
            'SELECT * FROM Contest WHERE id = $1',
            1495896251,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contest
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Contest.prisma().query_first(
            'SELECT * FROM Contest WHERE title = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContestCreateInput,
        include: Optional[types.ContestInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contest record.

        Parameters
        ----------
        data
            Contest record data
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The created Contest record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contest record from just the required fields
        contest = await Contest.prisma().create(
            data={
                # data to create a Contest record
                'title': 'igaibbfgj',
                'description': 'bggajdcbbi',
                'creatorId': 525761943,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContestCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contest records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contest record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Contest.prisma().create_many(
            data=[
                {
                    # data to create a Contest record
                    'title': 'hdgcajhjg',
                    'description': 'ejdjahicb',
                    'creatorId': 639686562,
                },
                {
                    # data to create a Contest record
                    'title': 'gfeaahdeh',
                    'description': 'bjafcgbffc',
                    'creatorId': 78746985,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContestWhereUniqueInput,
        include: Optional[types.ContestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contest record.

        Parameters
        ----------
        where
            Contest filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The deleted Contest record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contest = await Contest.prisma().delete(
            where={
                'id': 1398328302,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContestWhereUniqueInput,
        include: Optional[types.ContestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contest record.

        Parameters
        ----------
        where
            Contest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The found Contest record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contest = await Contest.prisma().find_unique(
            where={
                'id': 856000655,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContestWhereUniqueInput,
        include: Optional[types.ContestInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Contest record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Contest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The found Contest record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contest = await Contest.prisma().find_unique_or_raise(
            where={
                'id': 1452336924,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
        include: Optional[types.ContestInclude] = None,
        order: Optional[Union[types.ContestOrderByInput, List[types.ContestOrderByInput]]] = None,
        distinct: Optional[List[types.ContestScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contest records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contest records returned
        skip
            Ignore the first N results
        where
            Contest filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contest model
        order
            Order the returned Contest records by any field
        distinct
            Filter Contest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contest]
            The list of all Contest records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contest records
        contests = await Contest.prisma().find_many(take=10)

        # find the first 5 Contest records ordered by the description field
        contests = await Contest.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
        include: Optional[types.ContestInclude] = None,
        order: Optional[Union[types.ContestOrderByInput, List[types.ContestOrderByInput]]] = None,
        distinct: Optional[List[types.ContestScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contest record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contest model
        order
            Order the returned Contest records by any field
        distinct
            Filter Contest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contest
            The first Contest record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contest record ordered by the creatorId field
        contest = await Contest.prisma().find_first(
            skip=1,
            order={
                'creatorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
        include: Optional[types.ContestInclude] = None,
        order: Optional[Union[types.ContestOrderByInput, List[types.ContestOrderByInput]]] = None,
        distinct: Optional[List[types.ContestScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Contest record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contest model
        order
            Order the returned Contest records by any field
        distinct
            Filter Contest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contest
            The first Contest record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contest record ordered by the id field
        contest = await Contest.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContestUpdateInput,
        where: types.ContestWhereUniqueInput,
        include: Optional[types.ContestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contest record.

        Parameters
        ----------
        data
            Contest record data specifying what to update
        where
            Contest filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The updated Contest record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contest = await Contest.prisma().update(
            where={
                'id': 1573199653,
            },
            data={
                # data to update the Contest record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContestWhereUniqueInput,
        data: types.ContestUpsertInput,
        include: Optional[types.ContestInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contest filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contest model

        Returns
        -------
        prisma.models.Contest
            The created or updated Contest record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contest = await Contest.prisma().upsert(
            where={
                'id': 2013903098,
            },
            data={
                'create': {
                    'id': 2013903098,
                    'title': 'gfeaahdeh',
                    'description': 'bjafcgbffc',
                    'creatorId': 78746985,
                },
                'update': {
                    'title': 'gfeaahdeh',
                    'description': 'bjafcgbffc',
                    'creatorId': 78746985,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContestUpdateManyMutationInput,
        where: types.ContestWhereInput,
    ) -> int:
        """Update multiple Contest records

        Parameters
        ----------
        data
            Contest data to update the selected Contest records to
        where
            Filter to select the Contest records to update

        Returns
        -------
        int
            The total number of Contest records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contest records
        total = await Contest.prisma().update_many(
            data={
                'title': 'faajgfadf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contest records present in the database

        Parameters
        ----------
        select
            Select the Contest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contest.prisma().count()

        # results: prisma.types.ContestCountAggregateOutput
        results = await Contest.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContestCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
    ) -> types.ContestCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContestCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestWhereInput] = None,
        cursor: Optional[types.ContestWhereUniqueInput] = None,
    ) -> Union[int, types.ContestCountAggregateOutput]:
        """Count the number of Contest records present in the database

        Parameters
        ----------
        select
            Select the Contest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contest.prisma().count()

        # results: prisma.types.ContestCountAggregateOutput
        results = await Contest.prisma().count(
            select={
                '_all': True,
                'creatorId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContestCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContestWhereInput] = None
    ) -> int:
        """Delete multiple Contest records.

        Parameters
        ----------
        where
            Optional Contest filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contest records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contest records
        total = await Contest.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContestScalarFieldKeys'],
        *,
        where: Optional['types.ContestWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContestAvgAggregateInput'] = None,
        sum: Optional['types.ContestSumAggregateInput'] = None,
        min: Optional['types.ContestMinAggregateInput'] = None,
        max: Optional['types.ContestMaxAggregateInput'] = None,
        having: Optional['types.ContestScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContestCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContestScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContestScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContestGroupByOutput']:
        """Group Contest records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contest fields to group records by
        where
            Contest filter to select records
        take
            Limit the maximum number of Contest records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContestGroupByOutput]
            A list of dictionaries representing the Contest record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contest records by id values
        # and count how many records are in each group
        results = await Contest.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContestProblemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ContestProblem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ContestProblem.prisma().query_raw(
            'SELECT * FROM ContestProblem WHERE id = $1',
            1800624392,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ContestProblem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ContestProblem.prisma().query_first(
            'SELECT * FROM ContestProblem WHERE contestId = $1',
            2077067425,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContestProblemCreateInput,
        include: Optional[types.ContestProblemInclude] = None
    ) -> _PrismaModelT:
        """Create a new ContestProblem record.

        Parameters
        ----------
        data
            ContestProblem record data
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The created ContestProblem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ContestProblem record from just the required fields
        contestproblem = await ContestProblem.prisma().create(
            data={
                # data to create a ContestProblem record
                'contestId': 1672112838,
                'problemId': 926677639,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContestProblemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ContestProblem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ContestProblem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ContestProblem.prisma().create_many(
            data=[
                {
                    # data to create a ContestProblem record
                    'contestId': 1447624116,
                    'problemId': 1738083805,
                },
                {
                    # data to create a ContestProblem record
                    'contestId': 340946258,
                    'problemId': 601077795,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContestProblemWhereUniqueInput,
        include: Optional[types.ContestProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ContestProblem record.

        Parameters
        ----------
        where
            ContestProblem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The deleted ContestProblem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestproblem = await ContestProblem.prisma().delete(
            where={
                'id': 290603296,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContestProblemWhereUniqueInput,
        include: Optional[types.ContestProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ContestProblem record.

        Parameters
        ----------
        where
            ContestProblem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The found ContestProblem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestproblem = await ContestProblem.prisma().find_unique(
            where={
                'id': 1855826649,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContestProblemWhereUniqueInput,
        include: Optional[types.ContestProblemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ContestProblem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ContestProblem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The found ContestProblem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestproblem = await ContestProblem.prisma().find_unique_or_raise(
            where={
                'id': 1611009182,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
        include: Optional[types.ContestProblemInclude] = None,
        order: Optional[Union[types.ContestProblemOrderByInput, List[types.ContestProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ContestProblemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ContestProblem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ContestProblem records returned
        skip
            Ignore the first N results
        where
            ContestProblem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestProblem model
        order
            Order the returned ContestProblem records by any field
        distinct
            Filter ContestProblem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ContestProblem]
            The list of all ContestProblem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ContestProblem records
        contestproblems = await ContestProblem.prisma().find_many(take=10)

        # find the first 5 ContestProblem records ordered by the problemId field
        contestproblems = await ContestProblem.prisma().find_many(
            take=5,
            order={
                'problemId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
        include: Optional[types.ContestProblemInclude] = None,
        order: Optional[Union[types.ContestProblemOrderByInput, List[types.ContestProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ContestProblemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ContestProblem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContestProblem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestProblem model
        order
            Order the returned ContestProblem records by any field
        distinct
            Filter ContestProblem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContestProblem
            The first ContestProblem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContestProblem record ordered by the id field
        contestproblem = await ContestProblem.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
        include: Optional[types.ContestProblemInclude] = None,
        order: Optional[Union[types.ContestProblemOrderByInput, List[types.ContestProblemOrderByInput]]] = None,
        distinct: Optional[List[types.ContestProblemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ContestProblem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContestProblem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestProblem model
        order
            Order the returned ContestProblem records by any field
        distinct
            Filter ContestProblem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContestProblem
            The first ContestProblem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContestProblem record ordered by the contestId field
        contestproblem = await ContestProblem.prisma().find_first_or_raise(
            skip=1,
            order={
                'contestId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContestProblemUpdateInput,
        where: types.ContestProblemWhereUniqueInput,
        include: Optional[types.ContestProblemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ContestProblem record.

        Parameters
        ----------
        data
            ContestProblem record data specifying what to update
        where
            ContestProblem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The updated ContestProblem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contestproblem = await ContestProblem.prisma().update(
            where={
                'id': 446673791,
            },
            data={
                # data to update the ContestProblem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContestProblemWhereUniqueInput,
        data: types.ContestProblemUpsertInput,
        include: Optional[types.ContestProblemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ContestProblem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ContestProblem model

        Returns
        -------
        prisma.models.ContestProblem
            The created or updated ContestProblem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestproblem = await ContestProblem.prisma().upsert(
            where={
                'id': 300568396,
            },
            data={
                'create': {
                    'id': 300568396,
                    'contestId': 340946258,
                    'problemId': 601077795,
                },
                'update': {
                    'contestId': 340946258,
                    'problemId': 601077795,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContestProblemUpdateManyMutationInput,
        where: types.ContestProblemWhereInput,
    ) -> int:
        """Update multiple ContestProblem records

        Parameters
        ----------
        data
            ContestProblem data to update the selected ContestProblem records to
        where
            Filter to select the ContestProblem records to update

        Returns
        -------
        int
            The total number of ContestProblem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ContestProblem records
        total = await ContestProblem.prisma().update_many(
            data={
                'problemId': 632626069
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ContestProblem records present in the database

        Parameters
        ----------
        select
            Select the ContestProblem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContestProblem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestProblemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContestProblem.prisma().count()

        # results: prisma.types.ContestProblemCountAggregateOutput
        results = await ContestProblem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContestProblemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
    ) -> types.ContestProblemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContestProblemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestProblemWhereInput] = None,
        cursor: Optional[types.ContestProblemWhereUniqueInput] = None,
    ) -> Union[int, types.ContestProblemCountAggregateOutput]:
        """Count the number of ContestProblem records present in the database

        Parameters
        ----------
        select
            Select the ContestProblem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContestProblem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestProblemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContestProblem.prisma().count()

        # results: prisma.types.ContestProblemCountAggregateOutput
        results = await ContestProblem.prisma().count(
            select={
                '_all': True,
                'contestId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContestProblemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContestProblemWhereInput] = None
    ) -> int:
        """Delete multiple ContestProblem records.

        Parameters
        ----------
        where
            Optional ContestProblem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ContestProblem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ContestProblem records
        total = await ContestProblem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContestProblemScalarFieldKeys'],
        *,
        where: Optional['types.ContestProblemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContestProblemAvgAggregateInput'] = None,
        sum: Optional['types.ContestProblemSumAggregateInput'] = None,
        min: Optional['types.ContestProblemMinAggregateInput'] = None,
        max: Optional['types.ContestProblemMaxAggregateInput'] = None,
        having: Optional['types.ContestProblemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContestProblemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContestProblemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContestProblemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContestProblemGroupByOutput']:
        """Group ContestProblem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ContestProblem fields to group records by
        where
            ContestProblem filter to select records
        take
            Limit the maximum number of ContestProblem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContestProblemGroupByOutput]
            A list of dictionaries representing the ContestProblem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ContestProblem records by problemId values
        # and count how many records are in each group
        results = await ContestProblem.prisma().group_by(
            ['problemId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContestParticipantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ContestParticipant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ContestParticipant.prisma().query_raw(
            'SELECT * FROM ContestParticipant WHERE id = $1',
            1724011690,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ContestParticipant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ContestParticipant.prisma().query_first(
            'SELECT * FROM ContestParticipant WHERE contestId = $1',
            470157467,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContestParticipantCreateInput,
        include: Optional[types.ContestParticipantInclude] = None
    ) -> _PrismaModelT:
        """Create a new ContestParticipant record.

        Parameters
        ----------
        data
            ContestParticipant record data
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The created ContestParticipant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ContestParticipant record from just the required fields
        contestparticipant = await ContestParticipant.prisma().create(
            data={
                # data to create a ContestParticipant record
                'contestId': 1209209912,
                'userId': 1536744465,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContestParticipantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ContestParticipant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ContestParticipant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ContestParticipant.prisma().create_many(
            data=[
                {
                    # data to create a ContestParticipant record
                    'contestId': 424218998,
                    'userId': 2125632375,
                },
                {
                    # data to create a ContestParticipant record
                    'contestId': 536951780,
                    'userId': 924723277,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContestParticipantWhereUniqueInput,
        include: Optional[types.ContestParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ContestParticipant record.

        Parameters
        ----------
        where
            ContestParticipant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The deleted ContestParticipant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestparticipant = await ContestParticipant.prisma().delete(
            where={
                'id': 1621937922,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContestParticipantWhereUniqueInput,
        include: Optional[types.ContestParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ContestParticipant record.

        Parameters
        ----------
        where
            ContestParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The found ContestParticipant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestparticipant = await ContestParticipant.prisma().find_unique(
            where={
                'id': 1848832019,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContestParticipantWhereUniqueInput,
        include: Optional[types.ContestParticipantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ContestParticipant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ContestParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The found ContestParticipant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestparticipant = await ContestParticipant.prisma().find_unique_or_raise(
            where={
                'id': 1921528400,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
        include: Optional[types.ContestParticipantInclude] = None,
        order: Optional[Union[types.ContestParticipantOrderByInput, List[types.ContestParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ContestParticipantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ContestParticipant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ContestParticipant records returned
        skip
            Ignore the first N results
        where
            ContestParticipant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestParticipant model
        order
            Order the returned ContestParticipant records by any field
        distinct
            Filter ContestParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ContestParticipant]
            The list of all ContestParticipant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ContestParticipant records
        contestparticipants = await ContestParticipant.prisma().find_many(take=10)

        # find the first 5 ContestParticipant records ordered by the userId field
        contestparticipants = await ContestParticipant.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
        include: Optional[types.ContestParticipantInclude] = None,
        order: Optional[Union[types.ContestParticipantOrderByInput, List[types.ContestParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ContestParticipantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ContestParticipant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContestParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestParticipant model
        order
            Order the returned ContestParticipant records by any field
        distinct
            Filter ContestParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContestParticipant
            The first ContestParticipant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContestParticipant record ordered by the rank field
        contestparticipant = await ContestParticipant.prisma().find_first(
            skip=1,
            order={
                'rank': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
        include: Optional[types.ContestParticipantInclude] = None,
        order: Optional[Union[types.ContestParticipantOrderByInput, List[types.ContestParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ContestParticipantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ContestParticipant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContestParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContestParticipant model
        order
            Order the returned ContestParticipant records by any field
        distinct
            Filter ContestParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContestParticipant
            The first ContestParticipant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContestParticipant record ordered by the id field
        contestparticipant = await ContestParticipant.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContestParticipantUpdateInput,
        where: types.ContestParticipantWhereUniqueInput,
        include: Optional[types.ContestParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ContestParticipant record.

        Parameters
        ----------
        data
            ContestParticipant record data specifying what to update
        where
            ContestParticipant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The updated ContestParticipant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contestparticipant = await ContestParticipant.prisma().update(
            where={
                'id': 2100427849,
            },
            data={
                # data to update the ContestParticipant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContestParticipantWhereUniqueInput,
        data: types.ContestParticipantUpsertInput,
        include: Optional[types.ContestParticipantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ContestParticipant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ContestParticipant model

        Returns
        -------
        prisma.models.ContestParticipant
            The created or updated ContestParticipant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contestparticipant = await ContestParticipant.prisma().upsert(
            where={
                'id': 849140046,
            },
            data={
                'create': {
                    'id': 849140046,
                    'contestId': 536951780,
                    'userId': 924723277,
                },
                'update': {
                    'contestId': 536951780,
                    'userId': 924723277,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContestParticipantUpdateManyMutationInput,
        where: types.ContestParticipantWhereInput,
    ) -> int:
        """Update multiple ContestParticipant records

        Parameters
        ----------
        data
            ContestParticipant data to update the selected ContestParticipant records to
        where
            Filter to select the ContestParticipant records to update

        Returns
        -------
        int
            The total number of ContestParticipant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ContestParticipant records
        total = await ContestParticipant.prisma().update_many(
            data={
                'contestId': 928152175
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ContestParticipant records present in the database

        Parameters
        ----------
        select
            Select the ContestParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContestParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContestParticipant.prisma().count()

        # results: prisma.types.ContestParticipantCountAggregateOutput
        results = await ContestParticipant.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContestParticipantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
    ) -> types.ContestParticipantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContestParticipantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContestParticipantWhereInput] = None,
        cursor: Optional[types.ContestParticipantWhereUniqueInput] = None,
    ) -> Union[int, types.ContestParticipantCountAggregateOutput]:
        """Count the number of ContestParticipant records present in the database

        Parameters
        ----------
        select
            Select the ContestParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContestParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContestParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContestParticipant.prisma().count()

        # results: prisma.types.ContestParticipantCountAggregateOutput
        results = await ContestParticipant.prisma().count(
            select={
                '_all': True,
                'rank': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContestParticipantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContestParticipantWhereInput] = None
    ) -> int:
        """Delete multiple ContestParticipant records.

        Parameters
        ----------
        where
            Optional ContestParticipant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ContestParticipant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ContestParticipant records
        total = await ContestParticipant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContestParticipantScalarFieldKeys'],
        *,
        where: Optional['types.ContestParticipantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContestParticipantAvgAggregateInput'] = None,
        sum: Optional['types.ContestParticipantSumAggregateInput'] = None,
        min: Optional['types.ContestParticipantMinAggregateInput'] = None,
        max: Optional['types.ContestParticipantMaxAggregateInput'] = None,
        having: Optional['types.ContestParticipantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContestParticipantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContestParticipantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContestParticipantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContestParticipantGroupByOutput']:
        """Group ContestParticipant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ContestParticipant fields to group records by
        where
            ContestParticipant filter to select records
        take
            Limit the maximum number of ContestParticipant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContestParticipantGroupByOutput]
            A list of dictionaries representing the ContestParticipant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ContestParticipant records by id values
        # and count how many records are in each group
        results = await ContestParticipant.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models